# JVM

## 几个问题

jvm运行在操作系统之上。是jre的一部分

.java-->class file-->class loader <---> 运行时数据区（方法区、java栈、本地方法栈、堆、程序计数器）



### 类加载器

作用：加载class文件。 类在栈里面，对象在堆里面

#### ？？堆和栈的不同

1、申请方式的不同。栈由系统自动分配，而堆是人为申请开辟;

2、申请大小的不同。栈获得的空间较小，而堆获得的空间较大;

3、申请效率的不同。栈由系统自动分配，速度较快，而堆一般速度比较慢;

4、存储内容的不同。栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排;

5、底层不同。栈是连续的空间，而堆是不连续的空间。



栈负责保存我们的代码执行（或调用）路径。

堆则负责保存对象



值类型放在栈还是堆要看他们声明的地方：如果在方法内声明则在栈，如果在类里面声明则和对象一起在堆里。

### 双亲委派机制

appclassloader-->ext classloader -->bootstrap classloader

### 沙箱安全机制



### Native、方法区

native：凡是带了native关键字的，说明java的作用范围达不到了，回去调用底层C语音的类库。会进入本地方法栈，会调用本地方法接口 JNI（java native interface）

JNI作用：扩展java的使用。融合不同编程语言的为java所用！



### 方法区

所有线程共享的。

*静态变量、常量、类信息（构造方法、接口定义）、运行时的常量存在方法区中，但是实际的变量存在堆内存中，和方法区无关。*

方法区包括：static  final,Class,常量池。



### 栈

栈的生命周期和线程同步，线程结束栈就over了，不存在垃圾回收问题。

栈：8大基本类型、对象的引用、实例的方法



### 堆

一个jvm只有一个堆内存，堆内存大小是可以调节的。

堆分为三个区域：

- 新生区
  - 伊甸园区
  - 幸存0区 from
  - 幸存1区 to
  
  幸存区（from 和 to）谁空谁是to，to区永远是干净的。  每次GC都会将Eden活的对象移动到幸存区。
  
- 养老区

  当一个对象经历了15次GC都还没死就会进入养老区。（默认）

- 永久区（1.8叫元空间）
  - 存放JDK自身携带的Class对象，Interface元数据等。这个区域不存在垃圾回收，关闭JVM就会释放。
  - 方法区就在这个里面。

垃圾回收分为2种：轻量级和重量级

- 轻量级GC
  - 伊甸园区到幸存区
- 重量级GC
  - 新生区都清一次，清不掉的到养老区



垃圾回收主要在伊甸园区和养老区。幸存区主要是会到养老区。

内存满了就会报OOM（OutOfMemoryError），堆内存不够。



### 堆内存调优

获取最大内存：Runtime.getRuntime().maxMemory();

获取初始化内存： Runtime.getRuntime().totalMemory();

默认情况下 JVM总内存是电脑内存的 1/4 初始化内存是电脑内存的 1/64



运行参数设置：  VMOptions

设置初始化大小和最大内存，并打印：-Xms512m -Xmx1024m -XX:+PrintGCDetails



### 内存快照分析工具

MAT, Jprofiler

Idea安装Jprofiles插件

安装Jprofiles软件

发生OMM异常时dump出堆信息： -Xms8m -Xmx64m -XX:+HeapDumpOnOutOfMemoryError



### GC

gc的作用区域只有堆和方法区，方法区本质上也属于堆

垃圾回收不能自动

#### GC算法1：引用计数法

看每个对象被引用使用的次数，不被引用使用的就会被清楚。这种算法不高效，因为每个对象都要维护一个计数器。

#### GC算法2：复制算法

from区 的对象复制到to区， Eden区没有被gc掉的对象被复制到to 。这时候from区就变成了to区，to区就变成了from区。

好处：没有内存碎片。

坏处：浪费了内存空间，to区永远是空的

#### GC算法3：标记清除算法

GC时扫描对象，对活着的对象进行标记，对没有标记活着的对象进行清除。

有点：不需要额外的空间。

缺点：2次扫描，严重浪费时间，会产生内存碎片。

#### GC算法4：标记压缩

标记清除的优化，防止内存碎片产生。

在标记清除的基础上再次扫描，向一端移动对象。但是多了一个移动成本。



#### GC总结

内存效率：复制算法>标记清除算法>标记压缩算法

内存整齐度：复制算法=标记压缩算法>标记清除算法

内存利用率：标记压缩算法=标记清除算法>复制算法



年轻代：存活率低，适合使用复制算法。

老年代：区域大，存活率高。适合使用标记清除+标记压缩混合实现。



## JMM 

是什么：java内存模型  java memory model

是干嘛的：





### 题目：

- JVM的内存模型和分区，详细到每个区放什么
- 堆里面的分区有哪些？说说他们的特点
- GC的算法有哪些？怎么用的？
- 轻GC和重GC分别在什么时候发生？



